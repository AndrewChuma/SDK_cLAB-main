# ITMO.cLAB
## Описание
Шаблон проекта STM32CubeIDE для SDK-1.1M для загрузки в [ITMO.cLAB](https://sdk.ifmo.ru)
### Рекомендуемый инструментарий для разработки
- STM32CubeIDE
## Использование
### Конфигурирование проекта
Конфигурация портов ввода/вывода, а также различной перефирии производится в STM32CubeIDE (рекомендуется) или STM32CubeMX.<br>
Для избежания проблем, связанных с выполнением Вашего кода на SDK-1.1M в системе [ITMO.cLAB](https://sdk.ifmo.ru), рекомендуется **не изменять** уже настроенную в этом проекте периферию.
### Настройка векторов прерываний и компоновщика
Перед сборкой Вашего проекта рекомендуется убедиться в правильной настройке компановщика и векторов прерываний STM32F4:
1. В файле **system_stm32f4xx.c**:<br>
    Убедиться, что раскомментирована эта строка:
    ``` c
    #define VECT_TAB_SRAM
    ```
    Убедиться, что установлено правильное значение смещения:
    ``` c
    #define VECT_TAB_OFFSET  0xD000
    ```
2. В файле **STM32F407VGTX_RAM.ld**:
    ```
    MEMORY
    {
      CCMRAM    (xrw)    : ORIGIN = 0x10000000,   LENGTH = 64K
      RAM    (xrw)    : ORIGIN = 0x2000D000,   LENGTH = 76K
      FLASH    (rx)    : ORIGIN = 0x8000000,   LENGTH = 1024K
    }
    ```
3. В настройках компановщика (File -> Properties -> C/C++ Build -> Settings -> Tool Settings -> MCU GCC Linker -> General) выбран правильный Linker Script (STM32F407VGTX_RAM.ld).
### Описание функций
Для использования трассировочного буфера в файле ***main.c*** подключен заголовочный файл ***trace.h***, содержащий следующие функции:
 - ``` MX_TRACE_Init(); ```<br>
 Функция для инициализации трассировки.
 - ``` SDK_TRACE_Start(); ```<br>
 Функция для начала трассировки.
 - ``` SDK_TRACE_Timestamp(event, value); ```<br>
 Функция для сохранения временной метки одного события. Для сохранения доступны следующие события:
    - LED1-LED3 (Светодиоды)
    - PRINT (Вызов функции SDK_TRACE_Print)
    - P0-P9 (Пользовательские события)<br>

    Эти события определены в заголовочном файле ***trace.h***.<br>
    Аргумент **event** принимает код события, например LED3.<br>
    Аргумент **value** принимает значения 1 (начало события) или 0 (конец).

 - ``` SDK_TRACE_Print("%s","FooBar"); ```<br>
 Функция для сохранения форматной строки с временной меткой в трассировочный буфер. Работает аналогично функции printf().
 - ``` SDK_TRACE_Stop(); ```<br>
  Функция для завершения записи трассировки и сброса микроконтроллера.
### Рекомендации
На выполнение пользовательского кода отведено около 8 секунд, поэтому необходимо грамотно использовать циклы и задержки в своей программе.
 
### Задание к лабораторным работам
В рамках первой работы, вам необходимо разобраться с принципом работы UART:
 - Физический принцип работы (не углубляясь).
 - Описать и попробовать разные способы программной реализации:
	+ Блокирующие и неблокирующие функции (в отчете отразить разницу)
	+ Описать основные регистры UART
	+ Запись и чтение напрямую в регистр DR (типа USART2 -> DR = '<byte>') (отразить в отчете)
	+ Поработать с обработчиком прерываний (USARTX_IRQHandler(void)) (отразить в отчете)
	+ В выводе отразить разницу использования того или иного методов, разницу во времени работы, которую по идее можно увидеть в cLAB
	
В рамках второй работы:
 - Описать принцип работы с RTC
 - По аналогии с тем как установлена дата в файле rtc.c, установить время
 - Получить дату и время, и передать их по UART ( любым способом )
 
В рамках третьей работы:
 - Поработать с задачами freertos и очередями (там уже все создано, надо немного доработать)
 - Т.е. сейчас там сообщение передается из одной задачи в другу с помощью очереди, сделать обмен сообщениями между задачами
 - Посмотреть, что вообще можно делать с задачами (динамическое создание и удаление задач, функция task_yeld)
 
В рамках 4-й лабораторной:
 Изучить механизм DMA. 
 Осуществить работу с UART, используя DMA. 
 Сравнить время работы программы при использовании при использовании DMA с временем при использовании блокирующих и неблокирующих функций.
 В отчете подробно описать принцип работы DMA, отразить преимущества и в каких задачах стоит пользоваться, а в каких нет.
 Отметить какие блоки памяти задействуются при работе perepherial to memomry, и memory to memory.
 Что-то можно подсмотреть здесь:
 https://istarik.ru/blog/stm32/138.html
 Изучить данный документ:
 https://www.st.com/resource/en/errata_sheet/dm00037591-stm32f405407xx-and-stm32f415417xx-device-limitations-stmicroelectronics.pdf
 Не все, разделы связанные с DMA (p. 15-16), usart и ethernet.
 В отчете отметить ограничения на свой выбор (наиболее существенные)
 В отчетах привести листинг кода и скрины itmo.clab
